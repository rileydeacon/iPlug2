/**
 * NAME_PLACEHOLDER - iPlug2 Wasm AudioWorklet Processor
 *
 * This AudioWorkletProcessor loads the DSP WASM module and handles
 * audio processing and message passing with the main thread.
 *
 * The DSP module is loaded via addModule() with the WASM embedded as BASE64.
 *
 * Multi-instance support: Each processor creates its own DSP instance via
 * createInstance() and tracks it by instanceId. All WASM calls include the
 * instanceId to route to the correct plugin instance.
 */

class NAME_PLACEHOLDERProcessor extends AudioWorkletProcessor {
  constructor(options) {
    super();

    this.bufsize = 128; // Fixed by Web Audio API
    this.sr = sampleRate;
    this.numInputChannels = options.processorOptions?.numInputChannels || 0;
    this.numOutputChannels = options.processorOptions?.numOutputChannels || 2;
    this.isInstrument = options.processorOptions?.isInstrument || false;

    // Instance ID for multi-instance support (0 = not initialized)
    this.instanceId = 0;

    // Audio buffer pointers (allocated in WASM memory)
    this.inputPtrs = null;
    this.outputPtrs = null;
    this.inputPtrArray = 0;
    this.outputPtrArray = 0;

    // SharedArrayBuffer for low-latency visualization data (optional)
    this.sabBuffer = null;
    this.sabDataView = null;
    this.sabWriteIdx = null;
    this.sabCapacity = 0;

    // Get the Module from globalThis (loaded by addModule)
    this.Module = globalThis.Module;

    if (!this.Module) {
      console.error('NAME_PLACEHOLDER: DSP Module not found in globalThis');
      return;
    }

    // Create a new plugin instance and get its ID
    this.instanceId = this.Module.createInstance();
    if (!this.instanceId) {
      console.error('NAME_PLACEHOLDER: Failed to create DSP instance');
      return;
    }

    console.log('NAME_PLACEHOLDER: Created instance', this.instanceId);

    // Register this processor's port with the instance for postMessage callbacks
    if (!this.Module._instancePorts) this.Module._instancePorts = {};
    if (!this.Module._instanceProcessors) this.Module._instanceProcessors = {};
    this.Module._instancePorts[this.instanceId] = this.port;
    this.Module._instanceProcessors[this.instanceId] = this;

    // Allocate audio buffers in WASM memory
    this._allocateBuffers();

    // Initialize DSP
    this.Module.init(this.instanceId, this.sr, this.bufsize);

    // Send plugin info to main thread (for headless UI generation)
    this._sendPluginInfo();

    // Handle messages from main thread (parameter/MIDI changes)
    this.port.onmessage = this._onMessage.bind(this);
    this.port.start();
  }

  _allocateBuffers() {
    const Module = this.Module;
    const bufsize = this.bufsize;

    // Allocate input channel buffers
    this.inputPtrs = [];
    for (let i = 0; i < this.numInputChannels; i++) {
      const ptr = Module._malloc(bufsize * 4); // 4 bytes per float
      this.inputPtrs.push(ptr);
    }

    // Allocate output channel buffers
    this.outputPtrs = [];
    for (let i = 0; i < this.numOutputChannels; i++) {
      const ptr = Module._malloc(bufsize * 4);
      this.outputPtrs.push(ptr);
    }

    // Allocate pointer arrays for C++ (array of float*)
    const ptrSize = 4; // 32-bit pointers in WASM
    this.inputPtrArray = Module._malloc(this.numInputChannels * ptrSize);
    this.outputPtrArray = Module._malloc(this.numOutputChannels * ptrSize);

    // Set up pointer arrays
    for (let i = 0; i < this.numInputChannels; i++) {
      Module.setValue(this.inputPtrArray + i * ptrSize, this.inputPtrs[i], 'i32');
    }
    for (let i = 0; i < this.numOutputChannels; i++) {
      Module.setValue(this.outputPtrArray + i * ptrSize, this.outputPtrs[i], 'i32');
    }
  }

  /**
   * Free allocated WASM memory buffers and destroy the DSP instance.
   * Note: AudioWorkletProcessor has no destructor callback, so this must be
   * called explicitly when the processor is no longer needed. In practice,
   * the AudioWorkletGlobalScope is terminated when the AudioContext closes,
   * which frees all WASM memory. This method is provided for explicit cleanup
   * in long-running contexts where processors may be recreated.
   */
  _cleanup() {
    const Module = this.Module;
    if (!Module) return;

    // Free input channel buffers
    if (this.inputPtrs) {
      for (const ptr of this.inputPtrs) {
        if (ptr) Module._free(ptr);
      }
      this.inputPtrs = null;
    }

    // Free output channel buffers
    if (this.outputPtrs) {
      for (const ptr of this.outputPtrs) {
        if (ptr) Module._free(ptr);
      }
      this.outputPtrs = null;
    }

    // Free pointer arrays
    if (this.inputPtrArray) {
      Module._free(this.inputPtrArray);
      this.inputPtrArray = 0;
    }
    if (this.outputPtrArray) {
      Module._free(this.outputPtrArray);
      this.outputPtrArray = 0;
    }

    // Destroy the DSP instance
    if (this.instanceId) {
      console.log('NAME_PLACEHOLDER: Destroying instance', this.instanceId);
      Module.destroyInstance(this.instanceId);
      this.instanceId = 0;
    }
  }

  _onMessage(e) {
    const msg = e.data;

    switch (msg.type) {
      case 'param':
        this.Module.onParam(this.instanceId, msg.paramIdx, msg.value);
        break;

      case 'midi':
        this.Module.onMidi(this.instanceId, msg.status, msg.data1, msg.data2);
        break;

      case 'sysex':
        if (msg.data) {
          const data = new Uint8Array(msg.data);
          const ptr = this.Module._malloc(data.length);
          this.Module.HEAPU8.set(data, ptr);
          this.Module.onSysex(this.instanceId, ptr, data.length);
          this.Module._free(ptr);
        }
        break;

      case 'arbitrary':
        if (msg.data) {
          const data = new Uint8Array(msg.data);
          const ptr = this.Module._malloc(data.length);
          this.Module.HEAPU8.set(data, ptr);
          this.Module.onArbitraryMsg(this.instanceId, msg.msgTag, msg.ctrlTag, data.length, ptr);
          this.Module._free(ptr);
        } else {
          this.Module.onArbitraryMsg(this.instanceId, msg.msgTag, msg.ctrlTag, 0, 0);
        }
        break;

      case 'tick':
        this.Module.onIdleTick(this.instanceId);
        break;

      case 'attachSAB':
        // Attach SharedArrayBuffer for low-latency visualization data
        this.sabBuffer = msg.sab;
        this.sabDataView = new DataView(msg.sab);
        this.sabWriteIdx = new Uint32Array(msg.sab, 0, 1);
        this.sabCapacity = this.sabDataView.getUint32(8, true);
        break;

      case 'getPluginInfo':
        // Controller is requesting plugin info (in case it missed the initial broadcast)
        this._sendPluginInfo();
        break;

      case 'cleanup':
        // Explicit cleanup request - free WASM buffers and destroy instance
        this._cleanup();
        break;
    }
  }

  /**
   * Send plugin info to main thread
   */
  _sendPluginInfo() {
    if (!this.instanceId) return;

    if (this.Module.getPluginInfoJSON) {
      try {
        const jsonStr = this.Module.getPluginInfoJSON(this.instanceId);
        console.log('NAME_PLACEHOLDER Processor: pluginInfo JSON for instance', this.instanceId);
        const pluginInfo = JSON.parse(jsonStr);
        this.port.postMessage({ verb: 'pluginInfo', data: pluginInfo });
      } catch (e) {
        console.warn('NAME_PLACEHOLDER: Failed to send plugin info:', e);
      }
    }
  }

  /**
   * Write a message to the SharedArrayBuffer ring buffer
   * Called by DSP WASM via Module._instanceProcessors[id]._writeSABMessage()
   * @param {number} msgType - 0=SCVFD, 1=SCMFD, 2=SAMFD
   * @param {number} ctrlTag - Control tag
   * @param {number} msgTag - Message tag (for SCMFD/SAMFD)
   * @param {number} dataPtr - Pointer to data in WASM memory
   * @param {number} dataSize - Size of data in bytes
   * @returns {boolean} true if write succeeded
   */
  _writeSABMessage(msgType, ctrlTag, msgTag, dataPtr, dataSize) {
    try {
      if (!this.sabBuffer) return false;

      const headerSize = 16;  // SAB header
      const msgHeaderSize = 12; // message header (type + reserved + size + ctrlTag + msgTag)
      const alignedDataSize = (dataSize + 3) & ~3; // 4-byte align
      const totalMsgSize = msgHeaderSize + alignedDataSize;

      // Limit message size to prevent buffer overflow
      if (totalMsgSize > this.sabCapacity / 2) return false;

      const writeIdx = Atomics.load(this.sabWriteIdx, 0);
      const readIdx = Atomics.load(new Uint32Array(this.sabBuffer, 4, 1), 0);

      // Check available CONTIGUOUS space (message cannot wrap around)
      const spaceToEnd = this.sabCapacity - writeIdx;

      // If message doesn't fit contiguously, reset write index to 0
      let actualWriteIdx = writeIdx;
      if (totalMsgSize > spaceToEnd) {
        // Reset to beginning if there's space there
        if (totalMsgSize <= readIdx || readIdx <= writeIdx) {
          actualWriteIdx = 0;
        } else {
          return false; // No contiguous space available
        }
      }

      // Check we don't overwrite unread data
      if (readIdx > actualWriteIdx && (actualWriteIdx + totalMsgSize) >= readIdx) {
        return false;
      }

      const offset = headerSize + actualWriteIdx;

      // Bounds check
      if (offset + msgHeaderSize + dataSize > this.sabBuffer.byteLength) {
        return false;
      }

      // Write message header
      this.sabDataView.setUint8(offset, msgType);
      this.sabDataView.setUint8(offset + 1, 0); // reserved
      this.sabDataView.setUint16(offset + 2, dataSize, true);
      this.sabDataView.setInt32(offset + 4, ctrlTag, true);
      this.sabDataView.setInt32(offset + 8, msgTag, true);

      // Copy payload from WASM memory to SAB
      if (dataSize > 0 && dataPtr) {
        const src = new Uint8Array(this.Module.HEAPU8.buffer, dataPtr, dataSize);
        const dst = new Uint8Array(this.sabBuffer, offset + msgHeaderSize, dataSize);
        dst.set(src);
      }

      // Update write index atomically
      const nextWrite = actualWriteIdx + totalMsgSize;
      Atomics.store(this.sabWriteIdx, 0, nextWrite);

      return true;
    } catch (e) {
      console.error('_writeSABMessage error:', e);
      return false;
    }
  }

  process(inputs, outputs, parameters) {
    if (!this.instanceId) return false; // Instance destroyed

    const Module = this.Module;
    const bufsize = this.bufsize;

    // Copy input samples to WASM memory
    if (inputs.length > 0 && inputs[0].length > 0) {
      for (let ch = 0; ch < this.numInputChannels && ch < inputs[0].length; ch++) {
        Module.HEAPF32.set(inputs[0][ch], this.inputPtrs[ch] >> 2);
      }
    } else if (!this.isInstrument) {
      // Zero input buffers if no input available (for effects)
      for (let ch = 0; ch < this.numInputChannels; ch++) {
        Module.HEAPF32.fill(0, this.inputPtrs[ch] >> 2, (this.inputPtrs[ch] >> 2) + bufsize);
      }
    }

    // Call DSP processBlock via emscripten bindings
    // We pass the instance ID and pointer arrays (array of channel pointers)
    Module.processBlock(this.instanceId, this.inputPtrArray, this.outputPtrArray, bufsize);

    // Copy output samples from WASM memory
    if (outputs.length > 0 && outputs[0].length > 0) {
      for (let ch = 0; ch < this.numOutputChannels && ch < outputs[0].length; ch++) {
        outputs[0][ch].set(
          Module.HEAPF32.subarray(this.outputPtrs[ch] >> 2, (this.outputPtrs[ch] >> 2) + bufsize)
        );
      }
    }

    return true; // Keep processor alive
  }
}

registerProcessor('NAME_PLACEHOLDER_LC-processor', NAME_PLACEHOLDERProcessor);
